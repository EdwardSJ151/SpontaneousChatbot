import ast
import json
import lmql
from typing import Any, List, Tuple, Optional
from Levenshtein import distance as levenshtein_distance
import pickle
import time
import warnings
from typing import Any, List, Tuple, Optional
from models import ChannelData

import globalVariables  # file
from repo import ConversationDataRepo
from enum import Enum
import traceback
import inspect
from prompts import promptStore, Prompt
import documents
import tokenize
import dramatiq
from dramatiqConfig import initializer
import process
from lmql.runtime.bopenai import get_stats
## SETUP LOGGER
import logging
logger = logging.getLogger(__name__)
logger.setLevel(logging.DEBUG)

## END SETUP LOGGER

class InteractionTopic:
    def __init__(
        self,
        description: str,
        key: Optional[str] = None,
        value: Optional[str] = None,
        maxTimesToAsk: int = 2,
        examples: Optional[str] = None,
        instructions: Optional[str] = None,
        synonyms: List[str] = [],
        order: int = 0,
        autogenerated: bool = False,
        messages: List[Tuple[str,str]] = []
    ):  # constructor
        self.description = description
        self.key = key
        self.value = value
        self.maxTimesToAsk: int = maxTimesToAsk
        self.timesAsked: int = 0
        self.examples: str | None = examples
        self.instructions: str | None = instructions
        self.synonyms: List[str] | None = synonyms
        self.satisfactory: bool = False
        self.undisclosed: bool = False
        self.order = order
        self._autogenerated = autogenerated
        self._messages: List[Tuple[str,str]] = messages

    def complete(self) -> bool:
        if (self.timesAsked >= self.maxTimesToAsk) or self.satisfactory:
            return True
        else:
            return False

    def getSynonyms(self) -> str:
        if self.synonyms:
            return ", ".join(self.synonyms)
        else:
            return ""

    def toString(self) -> str:
        return f" - order: {self.order}, key: {self.key}, description: {self.description}"
    
    def messageToString(self) -> str:
        result = ""
        for message in self.messages:
            result = result + "\n" + f"{message[0]}: {message[1]}"
        return result

    def reset(self) -> bool:
        self.timesAsked = 0
        self.satisfactory = False
        self.undisclosed = False
        self.value = None

    @property
    def autogenerated(self):
        if not hasattr(self,'_autogenerated'):
            self._autogenerated = False
        return self._autogenerated
    @autogenerated.setter
    def autogenerated(self,value):
        self._autogenerated = value

    @property
    def messages(self):
        if not hasattr(self,'_messages'):
            self._messages = []
        return self._messages
    @messages.setter
    def messages(self,value):
        self._messages = value

class InteractionHelperParam:
    def __init__(self, param_type, param_value):
        self._type = param_type
        self._value = param_value

    @property
    def type(self):
        return self._type

    @type.setter
    def type(self, new_type):
        self._type = new_type

    @property
    def value(self):
        return self._value

    @value.setter
    def value(self, new_value):
        self._value = new_value

    def to_dict(self):
        return {'type': self._type, 'value': self._value}

    def to_json(self):
        return json.dumps(self.to_dict())


class InteractionHelperParams:
    def __init__(self):
        self._params = {}

    @property
    def params(self):
        return self._params

    @params.setter
    def params(self, new_params):
        self._params = new_params

    def add_param(self, param_name, param_type, param_value):
        param = InteractionHelperParam(param_type, param_value)
        self._params[param_name] = param

    def add_params_from_topics( self, topicsDict = dict[str, InteractionTopic] ):
        for k in topicsDict.keys():
            t: InteractionTopic = topicsDict[k]
            if t.complete():
                param = InteractionHelperParam( str, t.value )
                self._params[k] = param


    def get_param(self, param_name) -> InteractionHelperParam :
        return self._params.get(param_name)

    def get_param_value(self, param_name):
        return self.get_param(param_name).value
    
    def has_param(self, param_name):
        return param_name in self._params.keys()            

    def remove_param(self, param_name):
        if param_name in self._params:
            del self._params[param_name]

    def set_param(self, param_name, param_value):
        if param_name in self._params:
            self._params[param_name] = param_value

    def validate_params(self, param_list: List[str]):
        b = True
        for p in param_list:
            if p not in self._params.keys():
                b = False
                logger.error(f"Param not found {p}")



        return b

    def to_dict(self):
        return {param_name: param.to_dict() for param_name, param in self._params.items()}

    def to_json(self):
        return json.dumps(self.to_dict())
    
    def from_dict_list(self, json_list):
        print(json_list)
        print("---X")
        d = json.loads(json_list)
        for k,v in d.items():
            self.add_param(k, str, v)  
        return self


    def toString(self):
        p = ""
        for k, v in self._params.items():
            p+=f"{k}: {self.get_param_value(k)} \n"
        return p

class InteractionMessage():
    def __init__(self, type: str, message: str, order: int, custom_type: str = "standard"):
        self.type = type
        self.message = message
        self.order = order
        self.custom_type = custom_type

    def toString(self) -> str:
        return f"- {self.type}: {self.message}"

class InteractionConfig:
    def __init__(
        self,
        browserLanguage: str = 'pt-BR'
    ):
        self._maxTrials: int = 5
        self._maxInteraction: int = 100
        self._language = browserLanguage
    @property
    def maxTrials(self):
        return self._maxTrials
    @maxTrials.setter
    def maxTrials(self,value):
        self._maxTrials = value
    @property
    def maxInteraction(self):
        return self._maxInteraction
    @maxInteraction.setter
    def maxInteraction(self,value):
        self._maxInteraction = value
    @property
    def language(self):
        return self._language
    @language.setter
    def language(self,value):
        self._language = value

    def to_dict(self):
        return { "maxTrials": self._maxTrials, "maxTnteraction": self._maxInteraction, "language": self._language }

    def to_json(self):
        return json.dumps(self.to_dict())


class InteractionStructure(Enum):
    NOT_INITIALIZED = 0
    IDEATION_INTERACTION_NOT_STARTED = 100
    IDEATION_BOT_PRESENTATION = 110
    IDEATION_INTERACTION_CONTEXT = 120
    IDEATION_WAITING_USER_INTERACTION = 130
    IDEATION_RECAP = 140
    IDEATION_RESUME = 160
    IDEATION_END = 170

    IDEATION_SCAPE_AND_REDIRECT = 190

    ABORT_SCAPE_AND_REDIRECT = 195
    QUESTION_SCAPE_AND_REDIRECT = 196
    OFFENSIVE_SCAPE_AND_REDIRECT = 197

    PROPOSAL_INTERACTION_NOT_STARTED = 200
    PROPOSAL_BOT_PRESENTATION = 210
    PROPOSAL_INTERACTION_CONTEXT = 220
    PROPOSAL_WAITING_USER_INTERACTION = 230
    PROPOSAL_RECAP = 240
    PROPOSAL_RESUME = 260
    PROPOSAL_END = 270

    PROPOSAL_SCAPE_AND_REDIRECT = 290

    PROPOSAL_THIRD_PARTY_INTERACTION_NOT_STARTED = 300
    PROPOSAL_THIRD_PARTY_BOT_PRESENTATION = 310
    PROPOSAL_THIRD_PARTY_INTERACTION_CONTEXT = 320
    PROPOSAL_THIRD_PARTY_WAITING_USER_INTERACTION = 330
    PROPOSAL_THIRD_PARTY_RECAP = 340
    PROPOSAL_THIRD_THIRD_PARTY_RESUME = 360
    PROPOSAL_THIRD_THIRD_PARTY_END = 370

    PROPOSAL_THIRD_PARTY_SCAPE_AND_REDIRECT = 390

    REFINEMENT_INTERACTION_NOT_STARTED = 400
    REFINEMENT_BOT_PRESENTATION = 410
    REFINEMENT_INTERACTION_CONTEXT = 420
    REFINEMENT_WAITING_USER_INTERACTION = 430
    REFINEMENT_RECAP = 440
    REFINEMENT_RESUME = 460
    REFINEMENT_END = 470

    REFINEMENT_SCAPE_AND_REDIRECT = 490

class StateSchema:
    def __init__(self, name, parent=None):
        self.name = name
        self.parent = parent

class StateStack:
    def __init__(self):
        self._stack = []

    def push_state(self, name):
        parent = self._stack[-1].name if self._stack else None
        new_state = StateSchema(name=name, parent=parent)
        self._stack.append(new_state)

    def pop_state(self):
        if self._stack:
            return self._stack.pop()
        return None

    @property
    def current_state(self):
        return self._stack[-1].name if self._stack else None

    @property
    def current_state_parent(self):
        if self._stack and len(self._stack) > 1:
            return self._stack[-1].parent
        return None

    def is_empty(self):
        return len(self._stack) == 0

    def __iter__(self):
        self._index = len(self._stack)
        return self

    # The idea is that the stack is a LIFO structure, so we iterate from the last element to the first
    def __next__(self):
        if self._index > 0:
            self._index -= 1
            return self._stack[self._index]
        else:
            raise StopIteration


class Interaction:
    """Instances of this class are meant to represent a complete snapshot of a conversation, that can be saved and retrieved."""

    def __init__( self, key: str, browserLanguage: str = 'pt-BR' ):
        self._config = InteractionConfig(browserLanguage=browserLanguage)
        self._messages: List[InteractionMessage] = []
        self._state: InteractionStructure = InteractionStructure.NOT_INITIALIZED
        self._topicsDict: dict[str, InteractionTopic] = {}
        self._currentTopic: str = None
        self._key = key
        self._context: ChannelData = None
        self._custom_type: str = None
        self._stateStack: StateStack = StateStack()
        self._sendbird: bool = False

    @property
    def currentState(self) -> StateStack:
        return self._stateStack.current_state

    @currentState.setter
    def currentState(self, value):
        self._stateStack.push_state(value)

    @property
    def parentState(self) -> StateStack:
        return self._stateStack.current_state_parent

    @parentState.setter
    def parentState(self, value):
        self._stateStack.push_state(value)

    def popState(self):
        return self._stateStack.pop_state()

    @property
    def config(self) -> InteractionConfig:
        return self._config
    @config.setter
    def config(self,value):
        self._config = value

    @property
    def key(self) -> str:
        return self._key
    @key.setter
    def key(self,value):
        self._key = value

    @property
    def state(self) -> str:
        return self._state
    @state.setter
    def state(self,value):
        self._state = value
    #TO DO Get Context Data from BPM
    @property
    def context(self) -> Optional['ChannelData']:
        return self._context
    @context.setter
    def context(self, value):
        self._context = value

    @property
    def currentTopic(self):
        return self._currentTopic
    @currentTopic.setter
    def currentTopic(self,value):
        self._currentTopic = value

    @property
    def custom_type(self) -> str:
        return self._custom_type
    @custom_type.setter
    def custom_type(self, value):
        self._custom_type = value

    @property
    def messages(self) -> List[InteractionMessage]:
        return self._messages
    @messages.setter
    def messages(self,value):
        self._messages = value

    @property
    def topicsDict(self) -> dict[str, InteractionTopic]:
        return self._topicsDict
    @topicsDict.setter
    def topicsDict(self,value):
        self._topicsDict = value

    @property
    def sendbird(self) -> bool:
        return self._sendbird
    @sendbird.setter
    def sendbird(self,value):
        self._sendbird = value


    def askBot( interaction_instance, username: str = None, message: str = " "): 
        try:

            logger.debug(f"Parent State {interaction_instance.parentState}")
            logger.debug(f"Interaction State {interaction_instance.currentState}")
            process.Handler.sendTypingStatusToApi.send(interaction_instance.key)
            p = InteractionHelperParams()
            p.add_param("key", str, interaction_instance.key)
   
            match interaction_instance.currentState:
                case InteractionStructure.IDEATION_INTERACTION_NOT_STARTED | InteractionStructure.PROPOSAL_INTERACTION_NOT_STARTED | InteractionStructure.PROPOSAL_THIRD_PARTY_INTERACTION_NOT_STARTED | InteractionStructure.REFINEMENT_INTERACTION_NOT_STARTED:
                    #just change the state, prepared for static message when starts
                    if interaction_instance.currentState == InteractionStructure.IDEATION_INTERACTION_NOT_STARTED:
                        interaction_instance.currentState = InteractionStructure.IDEATION_BOT_PRESENTATION
                        interaction_instance = Interaction.askBot( interaction_instance, username, message )
                        return interaction_instance
                    if interaction_instance.currentState == InteractionStructure.PROPOSAL_INTERACTION_NOT_STARTED:
                        interaction_instance.currentState = InteractionStructure.PROPOSAL_BOT_PRESENTATION
                        interaction_instance = Interaction.askBot( interaction_instance, username, message )
                        return interaction_instance
                    if interaction_instance.currentState == InteractionStructure.PROPOSAL_THIRD_PARTY_INTERACTION_NOT_STARTED:
                        interaction_instance.currentState = InteractionStructure.PROPOSAL_THIRD_PARTY_BOT_PRESENTATION
                        interaction_instance = Interaction.askBot( interaction_instance, username, message )
                        return interaction_instance
                    if interaction_instance.currentState == InteractionStructure.REFINEMENT_INTERACTION_NOT_STARTED:
                        interaction_instance.currentState = InteractionStructure.REFINEMENT_BOT_PRESENTATION
                        interaction_instance = Interaction.askBot( interaction_instance, username, message )
                        return interaction_instance
                    return interaction_instance

                case InteractionStructure.IDEATION_BOT_PRESENTATION | InteractionStructure.PROPOSAL_BOT_PRESENTATION | InteractionStructure.PROPOSAL_THIRD_PARTY_BOT_PRESENTATION | InteractionStructure.REFINEMENT_BOT_PRESENTATION:
                    if interaction_instance.currentState == InteractionStructure.IDEATION_BOT_PRESENTATION:
                        context: InteractionHelperParams = interaction_instance.getContext()
                        #Prepare Params
                        # p = InteractionHelperParams()
                        p.add_param('userName',str, context.get_param_value('ownerName'))
                        p.add_param('language',str, interaction_instance.config.language )
                        p.add_params_from_topics( interaction_instance.topicsDict )
                        m = InteractionHelper.executePromptFromStore( "intro_ideation", p )
                        if m: interaction_instance.addMessage( "assistant", m, interaction_instance.sendbird )
                        interaction_instance.currentState = InteractionStructure.IDEATION_INTERACTION_CONTEXT
                        interaction_instance = Interaction.askBot( interaction_instance, username, message )
                        logger.debug(f"AS RESULT instance {interaction_instance.state}")

                        return interaction_instance
                    if interaction_instance.currentState == InteractionStructure.PROPOSAL_BOT_PRESENTATION:
                        context: InteractionHelperParams = interaction_instance.getContext()
                        #Prepare Params
                        # p = InteractionHelperParams()
                        p.add_param('userName',str, context.get_param_value('ownerName'))
                        p.add_param('language',str, interaction_instance.config.language )
                        p.add_param('ideasName', str, context.get_param_value('projectTitle'))
                        p.add_params_from_topics( interaction_instance.topicsDict )
                        m = InteractionHelper.executePromptFromStore( "intro_proposal_owner", p )
                        if m: interaction_instance.addMessage( "assistant", m, interaction_instance.sendbird )
                        interaction_instance.currentState = InteractionStructure.PROPOSAL_INTERACTION_CONTEXT
                        interaction_instance = Interaction.askBot( interaction_instance, username, message )
                        return interaction_instance
                    if interaction_instance.currentState == InteractionStructure.PROPOSAL_THIRD_PARTY_BOT_PRESENTATION:
                        context: InteractionHelperParams = interaction_instance.getContext()
                        #Prepare Params
                        # p = InteractionHelperParams()
                        p.add_param('userName',str, context.get_param_value('ownerName'))
                        p.add_param('language',str, interaction_instance.config.language )
                        #get the previous topics
                        p.add_param('topics', List[str],['Strategic Objectives', 'Scope'])
                        p.add_params_from_topics( interaction_instance.topicsDict )
                        m = InteractionHelper.executePromptFromStore( "intro_proposal_third_party", p )
                        if m: interaction_instance.addMessage( "assistant", m, interaction_instance.sendbird )
                        interaction_instance.currentState = InteractionStructure.PROPOSAL_THIRD_PARTY_INTERACTION_CONTEXT
                        interaction_instance = Interaction.askBot( interaction_instance, username, message )
                        return interaction_instance
                    if interaction_instance.currentState == InteractionStructure.REFINEMENT_BOT_PRESENTATION:
                        context: InteractionHelperParams = interaction_instance.getContext()
                        #Prepare Params
                        # p = InteractionHelperParams()
                        p.add_param('userName',str, context.get_param_value('ownerName'))
                        p.add_param('language',str, interaction_instance.config.language )
                        p.add_param('ideasName', str, context.get_param_value('projectTitle'))
                        p.add_params_from_topics( interaction_instance.topicsDict )
                        m = InteractionHelper.executePromptFromStore( "intro_refinement_owner", p )
                        if m: interaction_instance.addMessage( "assistant", m, interaction_instance.sendbird )
                        interaction_instance.currentState = InteractionStructure.REFINEMENT_INTERACTION_CONTEXT
                        interaction_instance = Interaction.askBot( interaction_instance, username, message )
                        return interaction_instance

                case InteractionStructure.IDEATION_INTERACTION_CONTEXT | InteractionStructure.PROPOSAL_INTERACTION_CONTEXT | InteractionStructure.PROPOSAL_THIRD_PARTY_INTERACTION_CONTEXT | InteractionStructure.REFINEMENT_INTERACTION_CONTEXT:
                    if interaction_instance.currentState == InteractionStructure.IDEATION_INTERACTION_CONTEXT:
                        context_message = f"My ideia name is {interaction_instance.topicsDict['ideasName'].value} and its description is {interaction_instance.topicsDict['description'].value}"
                        for t in interaction_instance.topicsDict.keys():
                            interaction_instance.topicsDict[t].messages = [(interaction_instance.topicsDict["proposersName"].value, context_message)]                            

                        interaction_instance.currentState = InteractionStructure.IDEATION_WAITING_USER_INTERACTION
                        return interaction_instance

                    if interaction_instance.currentState == InteractionStructure.PROPOSAL_INTERACTION_CONTEXT:
                        context: InteractionHelperParams = interaction_instance.getContext()
                        project = documents.Documents().getLastSummaryDoc( context.get_param_value('projectId'), context.get_param_value('ownerId') )
                        print(f"project: {project}")
                        # p = InteractionHelperParams()
                        p.add_param('language',str, interaction_instance.config.language)
                        p.add_param('project',str, project)
                        p.add_params_from_topics( interaction_instance.topicsDict )
                        m = InteractionHelper.executePromptFromStore( "context_prompt_owner", p )
                        if m: 
                            interaction_instance.addMessage( "assistant", m, interaction_instance.sendbird )
                            for t in interaction_instance.topicsDict.keys():
                                interaction_instance.topicsDict[t].messages = [("assistant", m)] 
                        interaction_instance.currentState = InteractionStructure.PROPOSAL_WAITING_USER_INTERACTION
                        interaction_instance = Interaction.askBot( interaction_instance, username, message )
                        return interaction_instance

                    if interaction_instance.currentState == InteractionStructure.PROPOSAL_THIRD_PARTY_INTERACTION_CONTEXT:
                        context: InteractionHelperParams = interaction_instance.getContext()
                        project = documents.getLastSummaryDoc( context.get_param_value('projectId'), context.get_param_value('ownerId') )
                        # p = InteractionHelperParams()
                        p.add_param('language',str, interaction_instance.config.language)
                        p.add_param('project',str, project)
                        p.add_param('owner', str, context.get_param_value('ownerName'))
                        p.add_params_from_topics( interaction_instance.topicsDict )
                        m = InteractionHelper.executePromptFromStore( "context_prompt_third_party", p )
                        if m: 
                            interaction_instance.addMessage( "assistant", m, interaction_instance.sendbird )
                            for t in interaction_instance.topicsDict.keys():
                                interaction_instance.topicsDict[t].messages = [("assistant", m)]
                        interaction_instance.currentState = InteractionStructure.PROPOSAL_THIRD_PARTY_WAITING_USER_INTERACTION
                        interaction_instance = Interaction.askBot( interaction_instance, username, message )
                        return interaction_instance
                    
                    if interaction_instance.currentState == InteractionStructure.REFINEMENT_INTERACTION_CONTEXT:
                        context: InteractionHelperParams = interaction_instance.getContext()
                        project = documents.Documents().getLastSummaryDoc( context.get_param_value('projectId'), context.get_param_value('ownerId') )
                        print(f"project: {project}")
                        # p = InteractionHelperParams()
                        p.add_param('language',str, interaction_instance.config.language)
                        p.add_param('project',str, project)
                        p.add_params_from_topics( interaction_instance.topicsDict )
                        m = InteractionHelper.executePromptFromStore( "context_prompt_owner", p )
                        if m: 
                            interaction_instance.addMessage( "assistant", m, interaction_instance.sendbird )
                            for t in interaction_instance.topicsDict.keys():
                                interaction_instance.topicsDict[t].messages = [("assistant", m)]
                        # Possible to add to a new state this code below ####
                        partialSumary = interaction_instance.getPartialSummary()
                        p.add_param('userName', str, context.get_param_value('ownerName'))
                        p.add_param('lastMessagesExchanged', str, partialSumary )
                        p.add_param('repeatAsk',bool, False )
                        p.add_param('topicDescription', str, interaction_instance.topicsDict[ interaction_instance.currentTopic ].description )
                        first_message = InteractionHelper.generateQuestion(p)
                        if first_message:
                            interaction_instance.addMessage( "assistant", first_message.strip(" \"`'\n"), interaction_instance.sendbird )
                            interaction_instance.topicsDict[interaction_instance.currentTopic].messages = [("assistant", first_message)]
                        ###########
                        interaction_instance.currentState = InteractionStructure.REFINEMENT_WAITING_USER_INTERACTION
                        # interaction_instance = Interaction.askBot( interaction_instance, username, message )
                        return interaction_instance

                case InteractionStructure.ABORT_SCAPE_AND_REDIRECT:
                    #########
                    # Here is necessary to send a message to the user to inform that the conversation is being aborted
                    #########

                    parentState = interaction_instance.parentState
                    interaction_instance.currentState = parentState

                    if interaction_instance.currentState == InteractionStructure.IDEATION_WAITING_USER_INTERACTION: interaction_instance.currentState = InteractionStructure.IDEATION_RESUME
                    if interaction_instance.currentState == InteractionStructure.PROPOSAL_WAITING_USER_INTERACTION: interaction_instance.currentState = InteractionStructure.PROPOSAL_RESUME
                    if interaction_instance.currentState == InteractionStructure.PROPOSAL_THIRD_PARTY_WAITING_USER_INTERACTION: interaction_instance.currentState = InteractionStructure.PROPOSAL_THIRD_THIRD_PARTY_RESUME
                    if interaction_instance.currentState == InteractionStructure.REFINEMENT_WAITING_USER_INTERACTION: interaction_instance.currentState = InteractionStructure.REFINEMENT_RESUME
                    interaction_instance = Interaction.askBot( interaction_instance, username, message )
                    return interaction_instance

                case InteractionStructure.QUESTION_SCAPE_AND_REDIRECT:
                    partialSumary = interaction_instance.getTopicMessages()

                    # p = InteractionHelperParams()

                    p.add_param('lastUserMessage', str, message)
                    p.add_param('userName', str, username )
                    p.add_param('lastMessagesExchanged', str, partialSumary)
                    p.add_param('language', str, interaction_instance.config.language)
                    p.add_param('topicDescription', str, interaction_instance.topicsDict[ interaction_instance.currentTopic ].description )

                    botAnswer = InteractionHelper.answerQuestionFromUser( p )
                    # interaction_instance.topicsDict[ interaction_instance.currentTopic ].messages.append( ("assistant", botAnswer.strip(" \"`'\n")) )
                    p.add_param('lastBotMessage', str, botAnswer.strip(" \"`'\n"))

                    # partialSumary = interaction_instance.getTopicMessages()
                    # p.add_param('lastMessagesExchanged', str, partialSumary)

                    # getBacktoTopicMessage = InteractionHelper.getBacktoCurrentTopic( p )

                    interaction_instance.addMessage( "assistant", botAnswer.strip(" \"`'\n"), interaction_instance.sendbird )
                    # interaction_instance.addMessage( "assistant", getBacktoTopicMessage.strip(" \"`'\n"), interaction_instance.sendbird)

                    parentState = interaction_instance.parentState
                    interaction_instance.currentState = parentState # Back to the last state
                    # interaction_instance = await Interaction.askBot( interaction_instance, username, message )
                    return interaction_instance

                case InteractionStructure.OFFENSIVE_SCAPE_AND_REDIRECT:
                    #########
                    # Here is necessary to send a request to the moderation channel to inform that the user has sent an offensive message
                    #########

                    #########
                    # Currently this state is "deactivated" and the conversation is being redirected to the last state
                    #########

                    parentState = interaction_instance.parentState
                    interaction_instance.currentState = parentState
                    # interaction_instance = Interaction.askBot( interaction_instance, username, message ) # Back to the last state
                    return interaction_instance

                case InteractionStructure.IDEATION_WAITING_USER_INTERACTION | InteractionStructure.PROPOSAL_WAITING_USER_INTERACTION | InteractionStructure.PROPOSAL_THIRD_PARTY_WAITING_USER_INTERACTION | InteractionStructure.REFINEMENT_WAITING_USER_INTERACTION:
                    lastBotMessage = interaction_instance.messages[-1] if interaction_instance.countMessage('all') > 0 and interaction_instance.messages[-1].type == 'assistant' else ''
                    lastUserMessage = message
                    # lastInteraction: Tuple[str,str] = ( lastBotMessage, lastUserMessage)
                    if lastBotMessage:
                        interaction_instance.topicsDict[ interaction_instance.currentTopic ].messages.append( ("assistant", lastBotMessage.message) )
                    interaction_instance.topicsDict[ interaction_instance.currentTopic ].messages.append( (username, lastUserMessage)  )
                    
                    interaction_instance.addMessage(type=username, message=message)

                    # p = InteractionHelperParams()
                    p.add_param('message',str, message)
                    p.add_param('lastBotMessage', str, lastBotMessage.message if lastBotMessage else '')
                    p.add_param('lastUserMessage', str, lastUserMessage)
                    # escape = False
                    escape = interaction_instance.analyzeEscapeFlows(p) # Escape is activated
                    print(f"escape: {escape}")
                    if escape:
                        if interaction_instance.currentState == InteractionStructure.IDEATION_WAITING_USER_INTERACTION: interaction_instance.currentState = InteractionStructure.IDEATION_SCAPE_AND_REDIRECT
                        if interaction_instance.currentState == InteractionStructure.PROPOSAL_WAITING_USER_INTERACTION: interaction_instance.currentState = InteractionStructure.PROPOSAL_SCAPE_AND_REDIRECT
                        if interaction_instance.currentState == InteractionStructure.PROPOSAL_THIRD_PARTY_WAITING_USER_INTERACTION: interaction_instance.currentState = InteractionStructure.PROPOSAL_THIRD_PARTY_WAITING_USER_INTERACTION
                        interaction_instance = Interaction.askBot( interaction_instance, username, message )
                        return interaction_instance
                    else:
                        #continue with topics
                        partialSumary = interaction_instance.getTopicMessages()
                        # topicsMessages = interaction_instance.topicsDict[interaction_instance.currentTopic].messageToString()
                        p.add_param('userName', str, username )
                        p.add_param('lastMessagesExchanged', str, partialSumary )

                        subTopics = interaction_instance.topicsDict.keys() #TO DO Filter subtopics first interaction, try to make a pause or recap before 4 interactions.
                        #change suggested by icaro, just current topic
                        interaction_instance = interaction_instance.analyzeQualityResponse( p, interaction_instance.currentTopic )
                        repeatAsk = interaction_instance.getSocraticFlag()
                        p.add_param('repeatAsk',bool, repeatAsk )
                        p.add_param('language',str, interaction_instance.config.language)
                        pendingTopics: List[str,InteractionTopic ] = {}

                        for k in interaction_instance.topicsDict.keys():
                            t: InteractionTopic = interaction_instance.topicsDict[k]
                            if not t.complete(): 
                                pendingTopics[k] = t
                        if pendingTopics:
                            dramatiq_messages = []
                            for k,t in pendingTopics.items():
                                data = {}
                                p.add_param('topicKey',str, t.key)
                                p.add_param('topicDescription',str, t.description)
                                for k in p.params:
                                    #vv: InteractionHelperParam = v
                                    logger.error(k)
                                    logger.error(p.get_param_value(k))
                                    data[k]= p.get_param_value(k)
                                dataAsJson = json.dumps(data)
                                result = InteractionHelper.checkRelevanceForTopic(dataAsJson)
                                dramatiq_messages.append(result)
                            

                            for res in dramatiq_messages:
                                key, relevance = res
                                if relevance:
                                    interaction_instance.topicsDict[key].messages.append( ("assistant", lastBotMessage.message))
                                    interaction_instance.topicsDict[key].messages.append( (username, lastUserMessage))
                                print(f"{key}: {relevance}")

                            if (not repeatAsk): #not repeatAsk and pendingTopics.count > 0):
                                pendingTopicsAsString = "\n".join([t.toString() for k,t in pendingTopics.items()])
                                p.add_param('pendingTopics', str, pendingTopicsAsString)
                                interaction_instance.currentTopic = InteractionHelper.chooseNextTopic(p)
                                interaction_instance.currentTopic = interaction_instance.topicCorrection(interaction_instance.currentTopic)
                            if interaction_instance.currentTopic != None:
                                interaction_instance.topicsDict[interaction_instance.currentTopic].timesAsked += 1

                            p.add_param('topicDescription', str, interaction_instance.topicsDict[ interaction_instance.currentTopic ].description )
                            m = InteractionHelper.generateQuestion(p)
                            if m:
                                interaction_instance.addMessage( "assistant", m.strip(" \"`'\n"), interaction_instance.sendbird )
                                interaction_instance.currentState = interaction_instance.currentState# continue in the same state
                                return interaction_instance
                            else:
                                print("nothing")
                                return interaction_instance
                        else:
                            if interaction_instance.currentState == InteractionStructure.IDEATION_WAITING_USER_INTERACTION: interaction_instance.currentState = InteractionStructure.IDEATION_RECAP
                            if interaction_instance.currentState == InteractionStructure.PROPOSAL_WAITING_USER_INTERACTION: interaction_instance.currentState = InteractionStructure.PROPOSAL_RECAP
                            if interaction_instance.currentState == InteractionStructure.PROPOSAL_THIRD_PARTY_WAITING_USER_INTERACTION: interaction_instance.currentState = InteractionStructure.PROPOSAL_THIRD_PARTY_RECAP
                            if interaction_instance.currentState == InteractionStructure.REFINEMENT_WAITING_USER_INTERACTION: interaction_instance.currentState = InteractionStructure.REFINEMENT_RECAP
                            interaction_instance = Interaction.askBot( interaction_instance, username, message )
                            return interaction_instance


                case InteractionStructure.IDEATION_RECAP | InteractionStructure.PROPOSAL_RECAP | InteractionStructure.PROPOSAL_THIRD_PARTY_RECAP | InteractionStructure.REFINEMENT_RECAP:
                    if interaction_instance.currentState == InteractionStructure.IDEATION_RECAP:
                        f: bool = any(interaction_instance.topicsDict[k].autogenerated for k in interaction_instance.topicsDict.keys())
                        if f:
                            interaction_instance.currentState = InteractionStructure.IDEATION_RESUME
                            interaction_instance = Interaction.askBot( interaction_instance, username, message )
                            return interaction_instance
                        else: ##There are not new topics added yet
                            context: InteractionHelperParams = interaction_instance.getContext()
                            partialSumary = interaction_instance.getSummaryFromTopics()
                            # p = InteractionHelperParams()
                            p.add_param('language',str, interaction_instance.config.language)
                            p.add_param('summary', str, partialSumary)
                            newTopics = InteractionHelper.generateAdditionalTopics(p)
                            p.add_param('hasmoreTopics', bool, newTopics !=None )

                            m = InteractionHelper.executePromptFromStore( "recap_for_new_topics", p)
                            if m:
                                interaction_instance.addMessage( "assistant", m, interaction_instance.sendbird )
                            if newTopics != None:
                                interaction_instance: Interaction = Interaction.setNewTopics( interaction_instance, newTopics, m)
                                interaction_instance.currentState = InteractionStructure.IDEATION_WAITING_USER_INTERACTION
                            else:
                                interaction_instance.currentState = InteractionStructure.IDEATION_RESUME

                    if interaction_instance.currentState == InteractionStructure.PROPOSAL_RECAP: interaction_instance.currentState = InteractionStructure.PROPOSAL_RESUME
                    if interaction_instance.currentState == InteractionStructure.PROPOSAL_THIRD_PARTY_RECAP: interaction_instance.currentState = InteractionStructure.PROPOSAL_THIRD_THIRD_PARTY_RESUME
                    if interaction_instance.currentState == InteractionStructure.REFINEMENT_RECAP: interaction_instance.currentState = InteractionStructure.REFINEMENT_RESUME
                    interaction_instance = Interaction.askBot( interaction_instance, username, message )
                    return interaction_instance


                case InteractionStructure.IDEATION_RESUME | InteractionStructure.PROPOSAL_RESUME | InteractionStructure.PROPOSAL_THIRD_THIRD_PARTY_RESUME | InteractionStructure.REFINEMENT_RESUME:
                    if interaction_instance.currentState == InteractionStructure.IDEATION_RESUME:
                        # p = InteractionHelperParams()
                        p.add_param('language',str, interaction_instance.config.language)
                        message_resume = InteractionHelper.executePromptFromStore("message_pre_resume", p)
                        if message_resume:
                            interaction_instance.addMessage("assistant", message_resume, interaction_instance.sendbird)
                        interaction_instance = Interaction.improveAnswerRedaction( interaction_instance )
                        partialSumary = interaction_instance.getSummaryFromTopics()
                        p.add_param('summary',str, partialSumary )
                        m = InteractionHelper.executePromptFromStore( "ideation_document", p)
                        if m:
                            interaction_instance.addMessage( "assistant", m, interaction_instance.sendbird, custom_type="final-doc" )

                        end_message = InteractionHelper.executePromptFromStore("end_message", p)
                        if end_message:
                            interaction_instance.addMessage("assistant", end_message, interaction_instance.sendbird)
                        interaction_instance.currentState = InteractionStructure.IDEATION_END
                        interaction_instance = Interaction.askBot( interaction_instance, username, message )

                    if interaction_instance.currentState == InteractionStructure.PROPOSAL_RESUME:
                        # p = InteractionHelperParams()
                        p.add_param('language',str, interaction_instance.config.language)
                        message_resume = InteractionHelper.executePromptFromStore("message_proposal_pre_resume", p)
                        if message_resume:
                            interaction_instance.addMessage("assistant", message_resume, interaction_instance.sendbird)
                        interaction_instance = Interaction.improveAnswerRedaction( interaction_instance )
                        partialSumary = interaction_instance.getSummaryFromTopics()
                        context: InteractionHelperParams = interaction_instance.getContext()
                        project = documents.Documents().getLastSummaryDoc( context.get_param_value('projectId'), context.get_param_value('ownerId') )
                        p.add_param('conversationSummary',str, partialSumary )
                        p.add_param('previousDoc',str, project )
                        m = InteractionHelper.executePromptFromStore( "project_proposal_document", p)
                        if m:
                            interaction_instance.addMessage( "assistant", m, interaction_instance.sendbird, custom_type="final-doc")
                        end_message = InteractionHelper.executePromptFromStore("end_proposal_message", p)
                        if end_message:
                            interaction_instance.addMessage("assistant", end_message, interaction_instance.sendbird)
                        interaction_instance.currentState = InteractionStructure.PROPOSAL_END
                        interaction_instance = Interaction.askBot(interaction_instance, username, message)

                    if interaction_instance.currentState == InteractionStructure.PROPOSAL_THIRD_THIRD_PARTY_RESUME:
                        interaction_instance.currentState = InteractionStructure.PROPOSAL_THIRD_THIRD_PARTY_END
                    
                    if interaction_instance.currentState == InteractionStructure.REFINEMENT_RESUME:
                        # p = InteractionHelperParams()
                        p.add_param('language',str, interaction_instance.config.language)
                        message_resume = InteractionHelper.executePromptFromStore("message_refinement_pre_resume", p)
                        if message_resume:
                            interaction_instance.addMessage("assistant", message_resume, interaction_instance.sendbird)
                        interaction_instance = Interaction.improveAnswerRedaction( interaction_instance )
                        partialSumary = interaction_instance.getSummaryFromTopics()
                        context: InteractionHelperParams = interaction_instance.getContext()
                        project = documents.Documents().getLastSummaryDoc( context.get_param_value('projectId'), context.get_param_value('ownerId') )
                        p.add_param('conversationSummary',str, partialSumary )
                        p.add_param('previousDoc',str, project )
                        m = InteractionHelper.executePromptFromStore( "project_refinement_document", p)
                        if m:
                            interaction_instance.addMessage( "assistant", m, interaction_instance.sendbird, custom_type="final-doc")
                        end_message = InteractionHelper.executePromptFromStore("end_refinement_message", p)
                        if end_message:
                            interaction_instance.addMessage("assistant", end_message, interaction_instance.sendbird)
                        interaction_instance.currentState = InteractionStructure.REFINEMENT_END
                        interaction_instance = Interaction.askBot(interaction_instance, username, message)

                    interaction_instance = Interaction.askBot( interaction_instance, username, message )
                    return interaction_instance

                case InteractionStructure.IDEATION_END | InteractionStructure.PROPOSAL_END | InteractionStructure.PROPOSAL_THIRD_THIRD_PARTY_END | InteractionStructure.REFINEMENT_END:
                    print("nothing") #todo archive channel
                    return interaction_instance
                case _:
                    return interaction_instance
        except Exception as e:
            logger.error(f"Error processing")
            logger.error(e)
            logger.error(traceback.format_exc())
            logger.info("Sending message to API")
            error_message = "We have our servers full, please resent your last message."
            process.Handler.sendMessageToApi(interaction_instance.key, error_message)
            return interaction_instance

    def initialize(self):
        logger.info("initizalize...")
        print(self.context)
        if self.context == None:
            raise Exception("You need define context before start")
        if self.custom_type == None:
            raise Exception("You need define custom_type before start")

        customType = self.custom_type if self.custom_type in globalVariables.TOPICS_ENSEMBLE else "Ideação de Desafios"

        logger.info(f"get {customType} topics")
        topicGroup = globalVariables.TOPICS_ENSEMBLE[customType]
        for t in topicGroup:
            if not t["key"] in self.topicsDict.keys():
                self.topicsDict[t["key"]] = InteractionTopic(**t)
        logger.debug( self.topicsDict.keys() )

        match customType:
            case "Ideação de Desafios":
                self.mapTopicsFromContext(
                    {
                        "ideasName": self.context.project.title,
                        "description": self.context.project.description,
                        "proposersName": self.context.users[0].fullname
                    }
                )
            case "Propostas de Projetos":
                self.mapTopicsFromContext(
                    {
                        "description": self.context.project.description,
                        "ideasName": self.context.project.title,
                        "proposersName": self.context.users[0].fullname
                    }
                )
            case "Refinamento de Requisitos":
                self.mapTopicsFromContext(
                    {
                        "description": self.context.project.description,
                        "ideasName": self.context.project.title,
                        "proposersName": self.context.users[0].fullname
                    }
                )

        if self.currentTopic == None:
            self.currentTopic = next(iter(self.topicsDict.items()))[0]

    #TO DO: Change origin of context Data from BPM
    def getContext(self) -> InteractionHelperParams:
        p = InteractionHelperParams()
        p.add_param('projectId', str, self.context.project.id )
        p.add_param('projectTitle',str, self.context.project.title )
        p.add_param('ownerId', str, self.context.users[0].id )
        p.add_param('ownerName', str, self.context.users[0].fullname)
        return p

    def addMessage(self, type: str, message: str, sendToSendbird: bool = False, custom_type: str = "standard") -> None:
        m = InteractionMessage(type, message, self.countMessage("all"), custom_type)
        self.messages.append(m)
        logger.info(f"Message {m.type}: {m.message}")
        if sendToSendbird and type == "assistant":
            logger.info("Sending message to API")
            process.Handler.sendMessageToApi(self.key, m.message, m.custom_type)
        

    def countMessage(self, type: str) -> int:
        q = 0
        for m in self.messages:
            if isinstance(m,InteractionMessage) and (m.type == type or type == 'all'):
                q+=1
        return q

    def getMessages(self, fromMessage: InteractionMessage = None):
        l: List[InteractionMessage] = []
        lastOrder = fromMessage.order if fromMessage != None else -1
        for m in reversed(self.messages):
            if m.order > lastOrder:
                l.insert(0, m)
        
        return l

    def getPendingTopics(self) -> str:
        """Generates a string with the topics of the conversation
        Returns:
        str: The string with the topics of the conversation
        """
        ts = "\n".join(
            [
                f"{k}: {t.description},"
                for k, t in self.topicsDict.items()
                if not t.complete()
            ]
        )
        return ts

    def getSummaryFromTopics(self ) -> str:
        t = ""
        for s in self.topicsDict.keys():
            satif = "satisfactory" if self.topicsDict[s].satisfactory else "unsatisfactory"
            undis = "undisclosed" if not self.topicsDict[s].undisclosed else " completed"
            t+= f"\n - topic: { self.topicsDict[s].key } description: {self.topicsDict[s].description} value: { self.topicsDict[s].value } "
        return t

    def getPartialSummary(self, maxMessages: int = 6) -> str:
        """Creates a partial summary of the conversation to reduce prompt size
        """
        # return self.topicsDict[self.currentTopic].messageToString()
        qMessages = self.countMessage('all')
        print(f"message count: {qMessages}")
        lastSetOfMessages = "\n".join([m.toString() for m in self.messages[-maxMessages:]]) 
        if qMessages <= maxMessages:
            return lastSetOfMessages
        else:
            prevSetOfMessages =  self.messages[:-maxMessages]
            messagesAsString = "\n".join([m.toString() for m in prevSetOfMessages])
            p = InteractionHelperParams()
            p.add_param('maxSentences',int, 6)
            p.add_param('messages', str, messagesAsString)
            summaryOfPrevMessages = self.getSummaryFromTopics()
            formatedResponse = (
                 f'Summary of the conversation up to this point: "{summaryOfPrevMessages}"\n'
                 f'Last messages exchanged: \n"{lastSetOfMessages}"\n'
            )
            return formatedResponse
        
    def getTopicMessages(self) -> str:
        return self.topicsDict[self.currentTopic].messageToString()

    def topicCorrection(self, rawKey: str ) -> str | None:
        """Counts the number of questions asked about a topic
        Args:
        key (str): The key of the topic to count the questions about
        Returns:
        str: The key of the topic to count the questions about
        """
        keysToIncompleteTopics = [k for k, v in self.topicsDict.items(
        ) if not v.complete()]
        if keysToIncompleteTopics:
            key = InteractionHelper.getMostSimilarString(rawKey, keysToIncompleteTopics)
            return key
        else:
            return None

    def countPendingTopics(self ) -> str | None:
        """Counts the number of questions asked about a topic
        Args:
        key (str): The key of the topic to count the questions about
        Returns:
        str: The key of the topic to count the questions about
        """
        keysToIncompleteTopics = [k for k, v in self.topicsDict.items() if not v.complete()]
        if keysToIncompleteTopics:
            return keysToIncompleteTopics.count()
        else:
            return 0

    def analyzeEscapeFlows( self, payload: InteractionHelperParams):
        """Classify the user interaction to take alternative path"""
        data = {}
        for k in payload.params:
            #vv: InteractionHelperParam = v
            logger.error(k)
            logger.error(payload.get_param_value(k))
            data[k]= payload.get_param_value(k)
        dataAsJson = json.dumps(data)
        isQuestionResult = InteractionHelper.evalIsAQuestion(dataAsJson)
        isOffensiveResult = InteractionHelper.evalOffensiveMessage(dataAsJson)
        isAbortResult = InteractionHelper.evalIsAskedToAbort(dataAsJson)

        # result = dramatiq.group([
        #     InteractionHelper.evalIsAQuestion.message(dataAsJson),
        #     InteractionHelper.evalOffensiveMessage.message(dataAsJson),
        #     InteractionHelper.evalIsAskedToAbort.message(dataAsJson)
        # ]).run()
        # result.wait(timeout=50_000)

        analyze_results = [
            isQuestionResult,
            isOffensiveResult,
            isAbortResult
        ]
        
        print(analyze_results)


        if (analyze_results[0]) == True and self.parentState != InteractionStructure.QUESTION_SCAPE_AND_REDIRECT: #Is a question
            print("nothing")
            self.currentState = InteractionStructure.QUESTION_SCAPE_AND_REDIRECT
            return True

        if (analyze_results[1]) == True and self.parentState != InteractionStructure.OFFENSIVE_SCAPE_AND_REDIRECT: #Is a offensive
            print("nothing")
            self.currentState = InteractionStructure.OFFENSIVE_SCAPE_AND_REDIRECT
            return True

        if (analyze_results[2]) == True and self.parentState != InteractionStructure.ABORT_SCAPE_AND_REDIRECT: #Is asked to abort
            print("nothing")
            self.currentState = InteractionStructure.ABORT_SCAPE_AND_REDIRECT
            return True

        return False

    def analyzeQualityResponse( self, payload: InteractionHelperParams, topicToEval: str ):
        #extract only the topics allowed to analyze in this step and that still have the flag completed in false
        filteredTopic: dict[str, InteractionTopic] = self.topicsDict[topicToEval]
        # for k in topicsToEval:
        #     filteredTopics[k] = self.topicsDict[k]
        # analyze = []
        # keyHelper = []
        # for k, topic in filteredTopics.items():
        p = InteractionHelperParams()
        p.add_param( 'userName', str, payload.get_param_value('userName'))
        p.add_param( 'lastMessagesExchanged', str, payload.get_param_value('lastMessagesExchanged') )
        p.add_param( 'topicValue', str, filteredTopic.value )
        p.add_param( 'topicDescription', str, filteredTopic.description )
        p.add_param( 'topicInstruction', str, filteredTopic.instructions if filteredTopic.instructions else filteredTopic.description )
        p.add_param( 'topicExample', str, filteredTopic.examples )
        analyze =  InteractionHelper.evalTopic(p)
        # keyHelper.append(k)

        logger.info(f"Result of analyze Quality Responses of {filteredTopic}")
        logger.info(f"Result of analyze Quality Responses {analyze}")
        info, satisfactory = analyze
        self.topicsDict[topicToEval].satisfactory = self.topicsDict[topicToEval].satisfactory or satisfactory
        self.topicsDict[topicToEval].value = info
        # for k, (info, satisfactory) in zip(keyHelper, analyze):
        #     logger.debug(f"Filling result in {k}: {info}")
        #     logger.debug(f"Filling satisfatory: {satisfactory}")
        #     self.topicsDict[k].satisfactory = self.topicsDict[k].satisfactory or satisfactory
        #     self.topicsDict[k].value = info
        return self

    def mapTopicsFromContext( self, mapCriteria: dict[str,str] ):
        for k,v in mapCriteria.items():
            if k in self.topicsDict:
                self.topicsDict[k].value = v
                self.topicsDict[k].satisfactory = True

    def getSocraticFlag( self, currentFlagState: bool = False ):
        print(f"Topic : {self.currentTopic}")
        topic = self.topicsDict[self.currentTopic]
        interactionCompleted = all(t.complete() for t in self.topicsDict.values())
        print(f"Succefull chat: {interactionCompleted}")
        if interactionCompleted: return False
        print(f"Q Asked: {topic.timesAsked}")
        if topic.timesAsked > 2: return False
        print(f"Satisfactory: {topic.satisfactory}")
        if topic.satisfactory: return False
        #print(f"Flag atual: {currentFlagState}")
        #if currentFlagState == True: return False
        return True

    def setNewTopics(interaction_instance, string: str, recapMessage: str = "") -> object:
        topicsDict = ast.literal_eval(string)
        for dictionary in topicsDict:
            dictKeys = [k for k in dictionary.keys()]
            if not ("key" in dictKeys and "description" in dictKeys):
                keyName = InteractionHelper.getMostSimilarString("key", dictKeys)
                descriptionName = InteractionHelper.getMostSimilarString("description", dictKeys)
                dictionary["key"] = dictionary[keyName]
                dictionary["description"] = dictionary[descriptionName]
                dictionary["autogenerated"] = True
                # dictionary["messages"] = [("assistant", recapMessage)]
            key = dictionary["key"]
            # Check if the key of new topics already exist in self.topicsDict
            if key in interaction_instance.topicsDict.keys():
                # if it does, continue to the next topic
                continue
            else:
                interaction_instance.topicsDict[key] = InteractionTopic(key=dictionary["key"],description=dictionary["description"], autogenerated=True, messages=[("assistant", recapMessage)])
        return interaction_instance

    def improveAnswerRedaction( interaction_instance ) -> object:
        for k, v in interaction_instance.topicsDict.items():
            messages: str = ', '.join(['({}, {})'.format(tuple[0], tuple[1]) for tuple in v.messages])
            p: InteractionHelperParams = InteractionHelperParams()
            p.add_param( 'topicDescription', str, v.description)
            p.add_param( 'topicInstruction', str, v.instructions )
            p.add_param( 'topicMessages', str, v.messageToString() )
            p.add_param( 'topicValue', str, v.value )
            improved_answer = InteractionHelper.executePromptFromStore( "improve_ideation_topic", p )
            interaction_instance.topicsDict[k].value = improved_answer
        return interaction_instance

    def toJson(self) -> str:
        jsonDict = {}
        for k, v in self.__dict__.items():
            match k:
                case 'topicsDict':
                    newJsonDict = {}
                    for kt, vt in v.items():
                        newJsonDict[kt] = vt.__dict__
                    jsonDict['topicsDict'] = newJsonDict
                case 'messages':
                    newJsonList = []
                    for m in v:
                        newJsonList.append(m.__dict__)
                    jsonDict['messages'] = newJsonList
                case 'context':
                    newJsonList = []
                    for m in v:
                        newJsonList.append(m.__dict__)
                    jsonDict['context'] = newJsonList
                case 'config':
                    newJsonList = []
                    for m in v:
                        newJsonList.append(m.__dict__)
                    jsonDict['config'] = newJsonList
                case _:
                    jsonDict[k] = v

        strJson = json.dumps(jsonDict, indent=2)
        return strJson


    def load(key: str, browserLanguage: str = 'pt-BR') -> Optional['Interaction']:
        conversation_instance: Interaction = Interaction(key, browserLanguage) #Empty instance
        conversation_data = None
        try:
            logger.debug(f"Looking for {key}")
            conversation_data = ConversationDataRepo().findByKey(key)
        except Exception as e:
            conversation_instance.save(True)
        if conversation_data != None and conversation_data.data !=None:
            try:
                deserialized_data = pickle.loads(conversation_data.data)
                for key in dir(deserialized_data):
                    if not key.startswith("__") and hasattr(conversation_instance, key):
                        try:
                            value = getattr(deserialized_data, key)
                            setattr(conversation_instance, key, value)
                        except Exception as ee:
                            logger.error(f"Error trying load property {key}")
            except Exception as e:
                logger.error("Error trying deserialize interaction",e)
        return conversation_instance

    def save(instance,insert: bool = False) -> None:
        # print( self.toJson() )
        logger.debug(f"Save: {instance._currentTopic} at key {instance.key} currentState {instance.state}")
        pickle_str = pickle.dumps( obj=instance, protocol=pickle.HIGHEST_PROTOCOL)
        if insert:
            ConversationDataRepo().insert(key=instance.key, data= pickle_str, engineType="standard") 
        else:
            ConversationDataRepo().update(key=instance.key, data= pickle_str)  # type: ignore

    def reset(self):
        ConversationDataRepo().delete(key=self.key)

class RetryLimitReachException(Exception):
    pass

class PromptParamsException(Exception):
    pass
class InteractionHelper:
    def validatePrompt( lmql_prompt:str ):
        try:
            tokens = list(tokenize.tokenize(iter(lmql_prompt.splitlines()).__next__))
        except tokenize.TokenError as e:
            logger.error(f"Error de token: {e}")
            # Aquí puedes intentar acceder a la información adicional, si está disponible
            # Por ejemplo, la cadena problemática podría estar en e.args[0][1]
            logger.info(e.args[0][1])
            return False
        else:
            logger.info("Analisis de tokens exitoso")
            return True

    def executePrompt(payload: InteractionHelperParams, lmql_prompt: str, model: str, prompt_key: str, max_len=8192) -> Any:
        data = {}
        for k in payload.params:
            #vv: InteractionHelperParam = v
            logger.error(k)
            logger.error(payload.get_param_value(k))
            data[k]= payload.get_param_value(k)
        dataAsJson = json.dumps(data)
        result = InteractionHelper._executePrompt.send(dataAsJson,lmql_prompt, model, prompt_key,max_len)
        a = result.get_result(block=True, backend=initializer.result_backend, timeout=150000)
        return a

    @dramatiq.actor(max_retries=3, store_results=True)
    async def _executePrompt(dataAsJson: str, lmql_prompt: str, model: str, prompt_key: str, max_len=8192) -> Any:
        #Add auxiliary functions
        payload = InteractionHelperParams()
        payload.from_dict_list(dataAsJson)
        payload.add_param( "getMostSimilarString", 'function', InteractionHelper.getMostSimilarString )

        logger.debug(f"Executing Prompt: \n{lmql_prompt}")

        max_attemps = 3
        start_time = time.time()
        try:
            f = lmql.query(lmql_prompt, is_async=True, model=model, max_len=max_len)
            with warnings.catch_warnings():
                warnings.simplefilter("error")
                result = await f(payload)
                end_time = time.time()
                stats = get_stats()
                logger.debug(f"Prompt_key: {prompt_key} : stats.tokens: {stats.tokens}")
                logger.debug(f"Execution Time of {prompt_key}: {end_time - start_time} secs. {1} shot/s")
                logger.debug(f"Result: \n{result}")
                return result
        except (TimeoutError) as e:
            if e is TimeoutError: logger.error(f"Aparently is too busy openAI")
            attemps = 1
            logger.error(f"Exception in trial {attemps}")
            logger.debug(f"Prompt: \n{lmql_prompt}")
            logger.debug(f"Model: \n{model}")
            logger.debug(f"Params: \n{payload.toString()}")

            logger.error(e)
            logger.error(traceback.format_exc())
            if attemps <= max_attemps:
                delay = 4000  ##exponential backoff
                if payload.has_param("key"):
                    key = payload.get_param_value("key")
                    error_message = "Ops... I have a delay with the model response. I will retry to ressend your message. Could you give me a few seconds, please."
                    process.Handler.sendMessageToApi(key, error_message)
                # dramatiq.requeue(e, delay=delay)
                raise Exception
            else:
                raise RetryLimitReachException()
        except (TypeError) as e:
            firma = inspect.signature(f)
            # Obtener información sobre los parámetros
            for nombre, parametro in firma.parameters.items():
                logger.debug(f"Name: {nombre}")
                if hasattr(parametro, 'position'):
                    logger.debug(f"Pos: {parametro.position}")
                logger.debug(f"Default: {parametro.default}")
                logger.debug(f"Reserved Error: {parametro.kind == inspect.Parameter.KEYWORD_ONLY}")
                logger.debug("------")
            logger.error(e)
            logger.error(traceback.format_exc())
            raise Exception
        except (tokenize.TokenError) as e:
            attemps = dramatiq.get_message().attempts
            logger.error("Tokenize error")
            logger.debug(f"Prompt: \n{lmql_prompt}")
            logger.debug(f"Model: \n{model}")
            logger.error(e)
            logger.error(traceback.format_exc())
            lmql_prompt  = lmql_prompt.encode('iso-8859-1','replace')
            if attemps <= 1:
                raise Exception
            else:
                raise RetryLimitReachException()
        except (RuntimeError, Exception) as e:
            logger.debug(f"Prompt: \n{lmql_prompt}")
            logger.debug(f"Model: \n{model}")
            logger.error(traceback.format_exc())
            raise Exception

    def executePromptFromStore( prompt_key: str, payload: InteractionHelperParams ) -> str:
        p: Prompt = promptStore[prompt_key]
        if not payload.validate_params( p.params ):
            error = ' '.join(p.params)
            error+= f" {prompt_key}"
            raise PromptParamsException( error )

        return InteractionHelper.executePrompt( payload, p.lmql, p.model, prompt_key )


    @dramatiq.actor(max_retries=0, store_results=True)
    def evalOffensiveMessage(dataAsJson: str) -> Tuple[bool, str]: # type: ignore
        payload = InteractionHelperParams()
        payload.from_dict_list(dataAsJson)
        prompt = '''lmql
        message = payload.get_param_value('message')
        getMostSimilarString = payload.get_param_value('getMostSimilarString')
        "Is '{message}' offensive or contains inappropriate words? Answer simply 'yes' or 'no':"
        "Is '{message}' offensive?: [OFFENSIVE]"
        OFFENSIVE = getMostSimilarString(OFFENSIVE, ["yes", "no"])
        if OFFENSIVE == "yes":
            OFFENSIVE = True
            "Generate a censored version of '{message}' changing some letters for symbols:"
            "Censored version: [CENSORED]"
        else:
            OFFENSIVE = False
            CENSORED = message
        return OFFENSIVE
        '''
        return InteractionHelper.executePrompt(payload, prompt,"openai/gpt-3.5-turbo-instruct" , "evalOffensiveMessage")

    @dramatiq.actor(max_retries=0, store_results=True)
    def evalIsAQuestion(dataAsJson: str) -> bool:  # type: ignore
        payload = InteractionHelperParams()
        payload.from_dict_list(dataAsJson)
        # payload.add_param( "getMostSimilarString", 'function', InteractionHelper.getMostSimilarString )
        prompt = '''lmql
        message = payload.get_param_value('message')
        getMostSimilarString = payload.get_param_value('getMostSimilarString')
        if message == " ":
            return False
        """
        Is the message below a question? 
        {message}.
        Answer simply 'yes' or 'no': [QUESTION]
        """

        QUESTION = getMostSimilarString(QUESTION, ["yes", "no"])
        if QUESTION == "yes":
          QUESTION = True
        else:
          QUESTION = False
        return QUESTION
        '''
        return InteractionHelper.executePrompt(payload, prompt,"openai/gpt-3.5-turbo-instruct","evalIsAQuestion")

    @dramatiq.actor(max_retries=0, store_results=True)
    def evalIsAskedToAbort(dataAsJson: str) -> bool:  # type: ignore
        payload = InteractionHelperParams()
        payload.from_dict_list(dataAsJson)
        if "@end" in payload.get_param_value('message'):
            return True
        return False
#        payload.add_param( "getMostSimilarString", 'function', InteractionHelper.getMostSimilarString )
        prompt = '''lmql
        message = payload.get_param_value('message')
        getMostSimilarString = payload.get_param_value('getMostSimilarString')
        "Does '{message}' explicitly indicates that the user wants the conversation to end? Answer simply 'yes' or 'no':"
        "The user wants to end the conversation?: [ABORT]"
        ABORT = getMostSimilarString(ABORT, ["yes", "no"])
        if ABORT == "yes":
            ABORT = True
        else:
            ABORT = False
        return ABORT
        '''
        return InteractionHelper.executePrompt(payload, prompt,"openai/gpt-3.5-turbo-instruct","evalIsAskedToAbort")

    @dramatiq.actor(max_retries=0, store_results=True)
    def checkRelevanceForTopic(dataAsJson: str) -> bool:
        payload = InteractionHelperParams()
        payload.from_dict_list(dataAsJson)

        key, relevance = InteractionHelper.executePromptFromStore( "check_relevance", payload )
        return [key, relevance]

    def chooseNextTopic(payload: InteractionHelperParams) -> str:  # type: ignore
        prompt = '''lmql
        pendingTopics = payload.get_param_value('pendingTopics')
        """
        {:user}
        Choose the most appropriate topic from the following json to continue the conversation. Return only the key corresponding to the chosen topic.
        Prioritize the order in the list
        {pendingTopics}

        {:assistant}
        The key corresponding to the most appropriate topic is: [KEY]
        """
        return KEY.strip()
        '''
        return InteractionHelper.executePrompt(payload, prompt,"openai/gpt-3.5-turbo-instruct","chooseNextTopic")
    
    def listSimilarTopics(payload: InteractionHelperParams) -> str:  # type: ignore
        prompt = '''lmql
        pendingTopics = payload.get_param_value('pendingTopics')
        messages = payload.get_param_value('messages')
        """
        {:user}
        Choose the most appropriate topic from the following json to continue the conversation. Return only the key corresponding to the chosen topic.
        Prioritize the order in the list
        {pendingTopics}

        {:assistant}
        The key corresponding to the most appropriate topic is: [KEY]
        """
        return KEY.strip()
        '''
        return InteractionHelper.executePrompt(payload, prompt,"openai/gpt-3.5-turbo-instruct","chooseNextTopic")


    def summarizeMessages(payload: InteractionHelperParams) -> str: # type: ignore
        prompt = '''lmql
        maxSentences = payload.get_param_value('maxSentences')
        messages = payload.get_param_value('messages')
        """
        {:system}
        System: You are an extractive summarizer. You are summarizing the conversation between you and the user.
        """
        """
        {:user}
        Please extract sentences as the summary. Considering the conversation and the following information:
        The summary must contain a max of {maxSentences} sentences.
        Conversation: {messages}.
        """
        """
        {:assistant}
        Summary of the conversation: [SUMMARY]
        """
        return SUMMARY
        '''
        return InteractionHelper.executePrompt(payload, prompt,"openai/gpt-3.5-turbo-instruct", "summarizeMessages", max_len=4096)


    def evalTopic(payload: InteractionHelperParams) -> Tuple[str, bool]: # type: ignore
#        payload.add_param( "getMostSimilarString", 'function', InteractionHelper.getMostSimilarString )
        prompt = '''lmql
        userName: str = payload.get_param_value('userName')
        lastMessagesExchanged: str = payload.get_param_value('lastMessagesExchanged')
        topicValue: str = payload.get_param_value('topicValue')
        topicDescription: str = payload.get_param_value('topicDescription')
        topicExample: str = payload.get_param_value('topicExample')
        topicInstruction: str = payload.get_param_value('topicInstruction')
        getMostSimilarString = payload.get_param_value('getMostSimilarString')

        """
        {:system}
        You are a senior consultant engaged in a discussion with {userName} regarding his/her project idea.
        You and {userName} exchanged the following messages up to this point: {lastMessagesExchanged}
        """
        if topicValue:
            """
            {:system}
            You also have the following prior information about {topicDescription}: {topicValue}
            """
        """
        {:user}
        Does {userName} explicitly states that he or she is unwilling to talk about {topicDescription}? Answer only 'yes' or 'no'.

        {:assistant}
        Does {userName} explicitly stated that he or she is unwilling to talk about '{topicDescription}'? [UNDISCLOSED]
        """
        UNDISCLOSED = getMostSimilarString(UNDISCLOSED, ['yes', 'no'])
        if UNDISCLOSED == "yes":
            return "Undisclosed", False

        # if topicExample: #TODO improve examples to take as only example and not take as an answer
        #     """
        #     {:user}
        #     Examples:
        #     {topicExample}
        #     """
        """
        {:user}
        Considering the information provided, extract all the information for '{topicInstruction if topicInstruction else topicDescription}'.
        {:assistant}
        {topicInstruction if topicInstruction else topicDescription}: [INFO]
        """
        """
        {:user}
        Considering {INFO}, is necessary to ask more questions to completely settle the subject '{topicInstruction if topicInstruction else topicDescription}'. Answer simply 'yes' or 'no': [SATISFACTORY]
        """
        SATISFACTORY = getMostSimilarString(SATISFACTORY, ["yes", "no"])
        if SATISFACTORY == "yes":
            SATISFACTORY = False
        else:
            SATISFACTORY = True
        return INFO, SATISFACTORY

        '''
        return InteractionHelper.executePrompt(payload, prompt,"openai/gpt-3.5-turbo-instruct", "evalTopic")

    def getBacktoCurrentTopic(payload: InteractionHelperParams) -> str: # type: ignore
        prompt = '''lmql
        userName: str = payload.get_param_value('userName')
        lastUserMessage = payload.get_param_value('lastUserMessage')
        lastBotMessage = payload.get_param_value('lastBotMessage')
        lastMessagesExchanged: str = payload.get_param_value('lastMessagesExchanged')
        language = payload.get_param_value('language')
        topicDescription: str = payload.get_param_value('topicDescription')
        """
        {:system}
        You are a senior consultant engaged in a discussion with {userName} regarding his/her project idea.
        Keep a direct and objective communication style. Be polite, but avoid expressing gratitude for {userName}'s messages, addressing insecurities or offering positive encouragement. Stay focused on the core issue at hand. As a structured consultant, limit each interaction to a single question. Use only the first person singular when referring to yourself. When you identify yourself, use the term "consultor".
        You and {userName} exchanged the following messages up to this point: '{lastMessagesExchanged}'
        {:user}
        You just answered the last {userName}'s question. Now, you need to get back to the current topic being developed.

        This is the current topic description: {topicDescription}
        This was the question asked by {userName}: {lastUserMessage}
        This was your answer: {lastBotMessage}

        Generate a polite message in {language} to get back to the current topic.

        {:assistant}
        Advisor message: [MESSAGE]
        """
        return MESSAGE
        '''
        return InteractionHelper.executePrompt(payload, prompt,"openai/gpt-3.5-turbo-instruct", "getBacktoCurrentTopic")


    def answerQuestionFromUser(payload: InteractionHelperParams) -> str: # type: ignore
        prompt = '''lmql
        lastUserMessage = payload.get_param_value('lastUserMessage')
        lastMessagesExchanged = payload.get_param_value('lastMessagesExchanged')
        userName = payload.get_param_value('userName')
        language = payload.get_param_value('language')
        topicDescription = payload.get_param_value('topicDescription')
        """
        {:system}
        You are a senior consultant guiding {userName} in elaborating his/her idea.
        Keep a direct and objective communication style. Be polite, but avoid expressing gratitude for {userName}'s messages, addressing insecurities or offering positive encouragement.
        Answer in the best way possible, providing a clear and concise response to {userName}'s last question.
        You two are chatting via instant messages.
        {:user}
        Formulate a polite and concise message to answer {userName} about '{lastUserMessage}' in {language} that helps the user to understand about his/her question.
        And end returning the last question that the assistant made.

        To help you to answer, the last messages exchanged are:
        {lastMessagesExchanged}

        {:assistant}
        Advisor answer to que question: [MESSAGE]
        """
        return MESSAGE
        '''
        return InteractionHelper.executePrompt(payload, prompt,"gpt-4","answerQuestionFromUser")

    def generateQuestion(payload: InteractionHelperParams) -> str: # type: ignore
        prompt = '''lmql
        repeatAsk = payload.get_param_value('repeatAsk')
        lastMessagesExchanged = payload.get_param_value('lastMessagesExchanged')
        userName = payload.get_param_value('userName')
        topicDescription = payload.get_param_value('topicDescription')
        language = payload.get_param_value('language')
        """
        {:system}
        You are a senior consultant guiding {userName} in elaborating his/her idea. Keep a direct and objective communication style. Be polite, but avoid expressing gratitude for {userName}'s messages, addressing insecurities or offering positive encouragement. Stay focused on the core issue at hand. As a structured consultant, limit each interaction to a single question. Use only the first person singular when referring to yourself. When you identify yourself, use the term "consultor".
        You two are chatting via instant messages.
        """
        if repeatAsk:
            """
            {:system}
            {userName}'s answer to the previous question was not detailed and did not provide any new information.
            Use the Socratic Method to guide the conversation toward a deeper understanding of the current topic via the following rules:

            Rule 1: Ask open-ended questions to encourage critical thinking;
            Rule 2: Avoid making statements or assertions, focus on asking;
            Rule 3: Seek clarification to ensure a clear understanding of the user's perspective;
            Rule 4: Clarify implications and consequences;
            Rule 5: If the user only agrees or disagrees with something, probe for specifics, for instance, "Thanks for sharing that. Can you pinpoint what specifically you agree/disagree with?";
            Rule 6: If the user is unsure, narrow down the topic, for instance, "That's completely fine. Let's try to explore this together. Can you tell me what aspects you are unsure about?";
            Rule 7: Ask for initial impressions, for instance, "No worries. Do you have any initial impressions or feelings, even if they're not fully formed?";
            Rule 8: Suggest speculative thinking, for instance, "I understand. What if you had to guess or imagine a possible answer, what might it be?";
            Rule 9: Propose a brainstorm, for instance, "No problem. How about we brainstorm some potential perspectives or ideas together?";
            Rule 10: Encourage any response, for instance, "That's alright. Even if it's just a random thought or feeling, feel free to share it."
            """
        """
        {:user}
        Formulate a polite and concise message with an end question to the user about '{topicDescription}' in {language} that prompts the user to advance in the idea.
        {lastMessagesExchanged}

        Advisor message: [MESSAGE]
        """
        """
        {:user}
        Rephrase {MESSAGE} with maintaining inflections, fillers and discourse markers, so that the language is more natural, not repetitive. Do not mentioning the user's name and give examples when the concept is very complex: [REPHRASE_MESSAGE]
        """
        return REPHRASE_MESSAGE
        '''
        return InteractionHelper.executePrompt(payload, prompt,"gpt-4","generateQuestion")


    def generateAdditionalTopics(payload: InteractionHelperParams, numNewTopics: int = 3) -> str:
#        payload.add_param( "getMostSimilarString", 'function', InteractionHelper.getMostSimilarString )
        prompt = '''lmql
        info = payload.get_param_value('summary')
        getMostSimilarString = payload.get_param_value('getMostSimilarString')
        numNewTopics = 3
        """
        {:system}
        You are a senior consultant guiding to the user in detailing hir idea. Stay focused on the core issue at hand. 
        All previous topics were answered with enough detail by the user.
        The Topics and its answers are as follows:
        {info}
        {:system}
        Having analyzed the previous exchange, do you think it is necessary to generate new topics to further develop the idea?
        The new topics would be used to extend the conversation in order to get more relevant information in a business point of view and why to implement this idea.
        Continue the conversation in order to advance the idea?
        Answer only "yes" or "no".
        {:assistant}
        It is necessary to generate new topics? [GENERATE]
        """
        GENERATE = getMostSimilarString(GENERATE, ["yes", "no"])
        if GENERATE == "no":
            return None
        else:
            """
            {:system}
            Generate {numNewTopics} new topics to continue the conversation and address critical points
            Create a list in Python with the following format:

            'key': 'nameOfTheTopic',
            'description': 'Description of the topic'

            Each topic is a dictionary in the list. Write all in english.
            """
            """
            {:assistant}
            {numNewTopics} new topics: [TOPICS]
            """

            return TOPICS
        '''
        return InteractionHelper.executePrompt(payload, prompt,"gpt-4","generateAdditionalTopics")




    def getMostSimilarString(word: str, listOfWords: List[str]) -> str:
        """Returns the most similar string in a list of strings to a given string, based on the Levenshtein distance

        Args:

        word (str): The string to compare
        listOfWords (List[str]): The list of strings to compare to

        Returns:

        str: The most similar string in the list
        """
        bestWord = listOfWords[0]
        bestDistance = levenshtein_distance(word, bestWord)
        for canditateWord in listOfWords[1:]:
            distance = levenshtein_distance(word, canditateWord)
            if distance < bestDistance:
                bestDistance = distance
                bestWord = canditateWord
        return bestWord

